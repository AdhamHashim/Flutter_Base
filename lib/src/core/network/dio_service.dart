import 'dart:io';
import 'package:dio/dio.dart';
import 'package:easy_localization/easy_localization.dart';
import 'package:flutter/foundation.dart';
import 'package:injectable/injectable.dart';
import 'package:pretty_dio_logger/pretty_dio_logger.dart';
import '../../../generated/locale_keys.g.dart';
import '../../config/language/languages.dart';
import '../../config/res/config_imports.dart';
import '../error/exceptions.dart';
import '../helpers/cache_service.dart';
import '../navigation/navigator.dart';
import '../shared/models/base_model.dart';
import 'backend_configuation.dart';
import 'configuration_interceptor.dart';
import 'extensions.dart';
import 'network_request.dart';
import 'network_service.dart';

@LazySingleton(as: NetworkService)
class DioService implements NetworkService {
  late final Dio _dio;

  DioService() {
    _dio = Dio()
      ..options.connectTimeout = const Duration(
        seconds: ConstantManager.connectTimeoutDuration,
      )
      ..options.receiveTimeout = const Duration(
        seconds: ConstantManager.recieveTimeoutDuration,
      )
      ..options.responseType = ResponseType.json;

    if (BackendConfiguation.type.isPhp) {
      _dio.interceptors.add(ConfigurationInterceptor());
    }

    if (kDebugMode) {
      _dio.interceptors.add(
        PrettyDioLogger(
          requestHeader: true,
          requestBody: true,
          responseBody: true,
          responseHeader: false,
          error: true,
          compact: true,
          maxWidth: 100,
        ),
      );
    }
  }

  Future<String> getBaseUrl() async {
    return await SecureStorage.read(SecureLocalVariableKeys.baseUrlKey) ?? '';
  }

  @override
  Future<void> updateBaseUrl() async {
    final baseUrl = await getBaseUrl();
    _dio.options.baseUrl = baseUrl;
  }

  @override
  void setToken(String token) {
    _dio.options.headers[HttpHeaders.authorizationHeader] =
        'Bearer ${token.replaceAll('Bearer', '').trim()}';
    changeLocale();
  }

  @override
  void removeToken() {
    _dio.options.headers.remove(HttpHeaders.authorizationHeader);
  }

  @override
  void changeLocale({String? locale}) {
    _dio.options.headers[HttpHeaders.acceptLanguageHeader] =
        locale ?? Go.context.locale.languageCode;
    _dio.options.headers['lang'] = locale ?? Go.context.locale.languageCode;
  }

  Future<Map<String, dynamic>> publicHeaders() async {
    return {"lang": Languages.currentLanguage.languageCode};
  }

  @override
  Future<BaseModel<Model>> callApi<Model>(
    NetworkRequest networkRequest, {
    Model Function(dynamic json)? mapper,
  }) async {
    try {
      final publicHeadersValue = await publicHeaders();
      await networkRequest.prepareRequestData();
      final response = await _dio.request(
        networkRequest.path,
        data: networkRequest.hasBodyAndProgress()
            ? networkRequest.isFormData
                  ? FormData.fromMap(networkRequest.body!)
                  : networkRequest.body
            : networkRequest.body,
        queryParameters: networkRequest.queryParameters,
        onSendProgress: networkRequest.hasBodyAndProgress()
            ? networkRequest.onSendProgress
            : null,
        onReceiveProgress: networkRequest.hasBodyAndProgress()
            ? networkRequest.onReceiveProgress
            : null,
        options: Options(
          method: networkRequest.asString(),
          headers: networkRequest.headers != null
              ? {...networkRequest.headers!, ...publicHeadersValue}
              : publicHeadersValue,
        ),
      );
      if (mapper != null) {
        return BaseModel.fromJson(response.data, jsonToModel: mapper);
      } else {
        return BaseModel.fromJson(response.data);
      }
    } on DioException catch (e) {
      return _handleError(e);
    }
  }

  dynamic _handleError(DioException error) {
    switch (error.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        throw NoInternetConnectionException(LocaleKeys.app_check_internet.tr());
      case DioExceptionType.badResponse:
        switch (error.response!.statusCode) {
          case HttpStatus.badRequest:
            throw BadRequestException(
              error.response?.data['message'] ??
                  LocaleKeys.app_bad_request.tr(),
            );
          case HttpStatus.unauthorized:
            throw UnauthorizedException(
              error.response?.data['message'] ??
                  LocaleKeys.app_bad_request.tr(),
            );
          case HttpStatus.locked:
            throw BlockedException(
              error.response?.data['message'] ??
                  LocaleKeys.app_bad_request.tr(),
            );
          case HttpStatus.forbidden:
            throw NeedActiveException(
              error.response?.data['message'] ??
                  LocaleKeys.app_bad_request.tr(),
            );
          case HttpStatus.notFound:
            throw NotFoundException(LocaleKeys.app_not_found.tr());
          case HttpStatus.conflict:
            throw ConflictException(
              error.response?.data['message'] ??
                  LocaleKeys.app_server_error.tr(),
            );
          case HttpStatus.internalServerError:
            throw InternalServerErrorException(
              error.response?.data['message'] ??
                  LocaleKeys.app_server_error.tr(),
            );
          default:
            throw ServerException(LocaleKeys.app_server_error.tr());
        }
      case DioExceptionType.cancel:
        throw ServerException(LocaleKeys.app_intenet_weakness.tr());
      case DioExceptionType.unknown:
        throw ServerException(
          error.response?.data['message'] ??
              LocaleKeys.app_exception_error.tr(),
        );
      default:
        throw ServerException(
          error.response?.data['message'] ??
              LocaleKeys.app_exception_error.tr(),
        );
    }
  }
}
